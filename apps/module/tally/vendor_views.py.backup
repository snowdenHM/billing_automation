import base64
import json
import logging
from datetime import datetime
from io import BytesIO

from PyPDF2 import PdfReader
from django.conf import settings
from django.core.files.base import ContentFile
from django.db import transaction
from django.shortcuts import get_object_or_404
from drf_spectacular.utils import extend_schema, OpenApiResponse
from pdf2image import convert_from_bytes
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.parsers import MultiPartParser, FormParser
from rest_framework.permissions import IsAuthenticated, BasePermission
from rest_framework.response import Response

from apps.module.tally.models import (
    TallyVendorBill, TallyVendorAnalyzedBill, TallyVendorAnalyzedProduct,
    Ledger, ParentLedger
)
from apps.module.tally.serializers import (
    TallyVendorBillSerializer,
    TallyVendorAnalyzedBillSerializer,
    VendorBillUploadSerializer,
    BillAnalysisRequestSerializer,
    BillVerificationSerializer,
    BillSyncRequestSerializer,
    BillSyncResponseSerializer
)
from apps.organizations.models import Organization
from apps.common.permissions import IsOrgAdmin

# OpenAI Client
try:
    from openai import OpenAI

    client = OpenAI(api_key=getattr(settings, 'OPENAI_API_KEY', None))
except ImportError:
    client = None

logger = logging.getLogger(__name__)


class OrganizationAPIKeyOrBearerToken(BasePermission):
    """
    Custom permission class that allows access via API key OR Bearer token authentication.
    This is an OR condition between authentication methods.
    """

    def has_permission(self, request, view):
        # Check for API key in the Authorization header
        auth_header = request.META.get('HTTP_AUTHORIZATION', '')

        if auth_header.startswith('Api-Key '):
            api_key_value = auth_header.replace('Api-Key ', '', 1)

            # Check if the API key exists and is valid
            from rest_framework_api_key.models import APIKey
            from apps.organizations.models import OrganizationAPIKey

            try:
                # First check if the raw API key is valid
                api_key_obj = APIKey.objects.get_from_key(api_key_value)

                # Check if the API key is valid with the actual key string
                if api_key_obj and api_key_obj.is_valid(api_key_value):
                    # Then check if it's linked to an organization
                    org_api_key = OrganizationAPIKey.objects.get(api_key=api_key_obj)

                    # Store the organization in the request for later use
                    request.organization = org_api_key.organization
                    return True
            except Exception:
                # Any exception means the API key is invalid or doesn't exist
                pass

        # If not authenticated via API key, check for Bearer token
        bearer_auth = IsAuthenticated().has_permission(request, view)
        if bearer_auth:
            # If authenticated via bearer token, also check admin permission
            return IsOrgAdmin().has_permission(request, view)

        return False


@extend_schema(tags=['Tally Vendor Bills'])
class TallyVendorBillViewSet(viewsets.ModelViewSet):
    """
    ViewSet for handling Tally Vendor Bills with complete workflow:
    Draft → Analyzed → Verified → Synced
    """
    serializer_class = TallyVendorBillSerializer
    permission_classes = [OrganizationAPIKeyOrBearerToken]
    parser_classes = [MultiPartParser, FormParser]

    def get_queryset(self):
        """Filter queryset based on organization"""
        organization = self.get_organization()
        return TallyVendorBill.objects.filter(organization=organization).order_by('-created_at')

    def get_organization(self):
        """Get organization from URL UUID parameter or API key"""
        org_id = self.kwargs.get('org_id')
        if org_id:
            return get_object_or_404(Organization, id=org_id)

        if hasattr(self.request, 'auth') and self.request.auth:
            from apps.organizations.models import OrganizationAPIKey
            try:
                org_api_key = OrganizationAPIKey.objects.get(api_key=self.request.auth)
                return org_api_key.organization
            except OrganizationAPIKey.DoesNotExist:
                pass

        if hasattr(self.request.user, 'memberships'):
            membership = self.request.user.memberships.first()
            if membership:
                return membership.organization
        return None

    def perform_create(self, serializer):
        """Set organization when creating vendor bill"""
        organization = self.get_organization()
        serializer.save(organization=organization)

    @extend_schema(
        summary="List Vendor Bills",
        description="Get all vendor bills for the organization",
        responses={200: TallyVendorBillSerializer(many=True)},
    )
    def list(self, request, *args, **kwargs):
        return super().list(request, *args, **kwargs)

    @extend_schema(
        summary="Upload Vendor Bills",
        description="Upload single or multiple vendor bill files (PDF, JPG, PNG)",
        request=VendorBillUploadSerializer,
        responses={201: TallyVendorBillSerializer(many=True)},
    )
    @action(detail=False, methods=['post'])
    def upload(self, request, *args, **kwargs):
        """Handle vendor bill file uploads with PDF splitting support"""
        serializer = VendorBillUploadSerializer(data=request.data)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

        organization = self.get_organization()
        if not organization:
            return Response(
                {'error': 'Organization not found'},
                status=status.HTTP_400_BAD_REQUEST
            )

        files = serializer.validated_data['files']
        file_type = serializer.validated_data['file_type']
        created_bills = []

        try:
            with transaction.atomic():
                for uploaded_file in files:
                    file_extension = uploaded_file.name.lower().split('.')[-1]

                    # Handle PDF splitting for multiple invoice files
                    if (file_type == TallyVendorBill.BillType.MULTI and
                            file_extension == 'pdf'):

                        pdf_bills = self._process_pdf_splitting(
                            uploaded_file, organization, file_type
                        )
                        created_bills.extend(pdf_bills)
                    else:
                        # Create single bill for non-PDF or single invoice type
                        bill = TallyVendorBill.objects.create(
                            file=uploaded_file,
                            file_type=file_type,
                            organization=organization
                        )
                        created_bills.append(bill)

            response_serializer = TallyVendorBillSerializer(created_bills, many=True)
            return Response(response_serializer.data, status=status.HTTP_201_CREATED)

        except Exception as e:
            logger.error(f"Error uploading vendor bills: {str(e)}")
            return Response(
                {'error': f'Error processing files: {str(e)}'},
                status=status.HTTP_400_BAD_REQUEST
            )

    def _process_pdf_splitting(self, pdf_file, organization, file_type):
        """Split PDF into individual pages and create separate bills"""
        created_bills = []

        try:
            pdf_file.seek(0)
            pdf_bytes = pdf_file.read()
            pdf = PdfReader(BytesIO(pdf_bytes))
            unique_id = datetime.now().strftime("%Y%m%d%H%M%S")

            for page_num in range(len(pdf.pages)):
                # Convert PDF page to image
                page_images = convert_from_bytes(
                    pdf_bytes,
                    first_page=page_num + 1,
                    last_page=page_num + 1
                )

                if page_images:
                    image_io = BytesIO()
                    page_images[0].save(image_io, format='JPEG')
                    image_io.seek(0)

                    # Create bill for this page
                    bill = TallyVendorBill.objects.create(
                        file=ContentFile(
                            image_io.read(),
                            name=f"BM-Page-{page_num + 1}-{unique_id}.jpg"
                        ),
                        file_type=file_type,
                        organization=organization
                    )
                    created_bills.append(bill)

        except Exception as e:
            logger.error(f"Error splitting PDF: {str(e)}")
            raise Exception(f"PDF processing failed: {str(e)}")

        return created_bills

    @extend_schema(
        summary="Analyze Vendor Bill",
        description="Analyze vendor bill using OpenAI to extract invoice data",
        request=BillAnalysisRequestSerializer,
        responses={
            200: TallyVendorAnalyzedBillSerializer,
            400: OpenApiResponse(description="Analysis failed")
        }
    )
    @action(detail=False, methods=['post'])
    def analyze(self, request, *args, **kwargs):
        """Analyze vendor bill using OpenAI"""
        serializer = BillAnalysisRequestSerializer(data=request.data)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

        bill_id = serializer.validated_data['bill_id']
        organization = self.get_organization()

        try:
            bill = TallyVendorBill.objects.get(
                id=bill_id,
                organization=organization
            )
        except TallyVendorBill.DoesNotExist:
            return Response(
                {'error': 'Bill not found'},
                status=status.HTTP_404_NOT_FOUND
            )

        if bill.status != TallyVendorBill.BillStatus.DRAFT:
            return Response(
                {'error': 'Bill is not in draft status'},
                status=status.HTTP_400_BAD_REQUEST
            )

        try:
            analyzed_bill = self._analyze_bill_with_ai(bill, organization)
            serializer = TallyVendorAnalyzedBillSerializer(analyzed_bill)
            return Response(serializer.data, status=status.HTTP_200_OK)

        except Exception as e:
            logger.error(f"Bill analysis failed: {str(e)}")
            return Response(
                {'error': f'Analysis failed: {str(e)}'},
                status=status.HTTP_400_BAD_REQUEST
            )

    def _analyze_bill_with_ai(self, bill, organization):
        """Analyze bill using OpenAI API"""
        if not client:
            raise Exception("OpenAI client not configured")

        # Read file and convert to base64
        try:
            with open(bill.file.path, 'rb') as f:
                image_base64 = base64.b64encode(f.read()).decode('utf-8')
        except Exception as e:
            raise Exception(f"Error reading bill file: {str(e)}")

        # Invoice schema for AI extraction
        invoice_schema = {
            "$schema": "http://json-schema.org/draft/2020-12/schema",
            "title": "Invoice",
            "description": "A simple invoice format",
            "type": "object",
            "properties": {
                "invoiceNumber": {"type": "string"},
                "dateIssued": {"type": "string", "format": "date"},
                "dueDate": {"type": "string", "format": "date"},
                "from": {
                    "type": "object",
                    "properties": {
                        "name": {"type": "string"},
                        "address": {"type": "string"}
                    }
                },
                "to": {
                    "type": "object",
                    "properties": {
                        "name": {"type": "string"},
                        "address": {"type": "string"}
                    }
                },
                "items": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "description": {"type": "string"},
                            "quantity": {"type": "number"},
                            "price": {"type": "number"}
                        }
                    }
                },
                "total": {"type": "number"},
                "igst": {"type": "number"},
                "cgst": {"type": "number"},
                "sgst": {"type": "number"}
            }
        }

        # AI processing request
        try:
            response = client.chat.completions.create(
                model='gpt-4o',
                response_format={"type": "json_object"},
                messages=[{
                    "role": "user",
                    "content": [
                        {
                            "type": "text",
                            "text": f"Extract invoice data in JSON format using this schema: {json.dumps(invoice_schema)}"
                        },
                        {
                            "type": "image_url",
                            "image_url": {"url": f"data:image/jpeg;base64,{image_base64}"}
                        }
                    ]
                }],
                max_tokens=1000
            )
            json_data = json.loads(response.choices[0].message.content)
        except Exception as e:
            raise Exception(f"AI processing failed: {str(e)}")

        # Process and save extracted data
        return self._process_analysis_data(bill, json_data, organization)

    def _process_analysis_data(self, bill, json_data, organization):
        """Process AI extracted data and create analyzed bill"""
        try:
            # Extract relevant data
            if "properties" in json_data:
                # Handle schema format
                relevant_data = {
                    "invoiceNumber": json_data["properties"]["invoiceNumber"]["const"],
                    "dateIssued": json_data["properties"]["dateIssued"]["const"],
                    "dueDate": json_data["properties"]["dueDate"]["const"],
                    "from": json_data["properties"]["from"]["properties"],
                    "to": json_data["properties"]["to"]["properties"],
                    "items": [
                        {
                            "description": item["description"]["const"],
                            "quantity": item["quantity"]["const"],
                            "price": item["price"]["const"]
                        }
                        for item in json_data["properties"]["items"]["items"]
                    ],
                    "total": json_data["properties"]["total"]["const"],
                    "igst": json_data["properties"]["igst"]["const"],
                    "cgst": json_data["properties"]["cgst"]["const"],
                    "sgst": json_data["properties"]["sgst"]["const"],
                }
            else:
                relevant_data = json_data

            # Save analyzed data to bill
            bill.analysed_data = relevant_data
            bill.save(update_fields=['analysed_data'])

            # Extract required fields
            invoice_number = relevant_data.get('invoiceNumber', '').strip()
            date_issued = relevant_data.get('dateIssued', '')
            company_name = relevant_data.get('from', {}).get('name', '').strip().lower()

            # Parse date
            bill_date = None
            if date_issued:
                try:
                    bill_date = datetime.strptime(date_issued, '%Y-%m-%d').date()
                except ValueError:
                    pass

            # Find vendor ledger
            vendor = self._find_vendor_ledger(company_name, organization)

            # Determine GST type
            igst_val = float(relevant_data.get('igst') or 0)
            cgst_val = float(relevant_data.get('cgst') or 0)
            sgst_val = float(relevant_data.get('sgst') or 0)

            if igst_val > 0:
                gst_type = TallyVendorAnalyzedBill.GSTType.IGST
            elif cgst_val > 0 or sgst_val > 0:
                gst_type = TallyVendorAnalyzedBill.GSTType.CGST_SGST
            else:
                gst_type = TallyVendorAnalyzedBill.GSTType.UNKNOWN

            # Create analyzed bill
            with transaction.atomic():
                analyzed_bill = TallyVendorAnalyzedBill.objects.create(
                    selected_bill=bill,
                    vendor=vendor,
                    bill_no=invoice_number,
                    bill_date=bill_date,
                    igst=igst_val,
                    cgst=cgst_val,
                    sgst=sgst_val,
                    total=relevant_data.get('total', 0),
                    note="AI Analyzed Bill",
                    organization=organization,
                    gst_type=gst_type
                )

                # Create analyzed products
                product_instances = []
                for item in relevant_data.get('items', []):
                    product = TallyVendorAnalyzedProduct(
                        vendor_bill_analyzed=analyzed_bill,
                        item_details=item.get('description', ''),
                        price=float(item.get('price', 0) or 0),
                        quantity=int(item.get('quantity', 0) or 0),
                        amount=float(item.get('price', 0) or 0) * int(item.get('quantity', 0) or 0),
                        organization=organization
                    )
                    product_instances.append(product)

                TallyVendorAnalyzedProduct.objects.bulk_create(product_instances)

                # Update bill status
                bill.status = TallyVendorBill.BillStatus.ANALYSED
                bill.process = True
                bill.save(update_fields=['status', 'process'])

                return analyzed_bill

        except Exception as e:
            raise Exception(f"Error processing analysis data: {str(e)}")

    def _find_vendor_ledger(self, company_name, organization):
        """Find matching vendor ledger"""
        try:
            parent_ledger = ParentLedger.objects.get(
                parent="Sundry Creditors",
                organization=organization
            )
            vendor_list = Ledger.objects.filter(
                parent=parent_ledger,
                organization=organization
            )

            # Find matching vendor (case-insensitive exact match first)
            vendor = vendor_list.filter(name__iexact=company_name).first()
            if not vendor:
                vendor = vendor_list.filter(name__icontains=company_name).first()

            return vendor

        except ParentLedger.DoesNotExist:
            return None

    @extend_schema(
        summary="Verify Vendor Bill",
        description="Verify analyzed vendor bill data and mark as verified",
        request=BillVerificationSerializer,
        responses={200: TallyVendorAnalyzedBillSerializer}
    )
    @action(detail=False, methods=['post'])
    def verify(self, request, *args, **kwargs):
        """Verify analyzed vendor bill"""
        serializer = BillVerificationSerializer(data=request.data)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

        bill_id = request.data.get('bill_id')
        organization = self.get_organization()

        try:
            bill = TallyVendorBill.objects.get(id=bill_id, organization=organization)
            analyzed_bill = TallyVendorAnalyzedBill.objects.get(selected_bill=bill)
        except (TallyVendorBill.DoesNotExist, TallyVendorAnalyzedBill.DoesNotExist):
            return Response(
                {'error': 'Bill or analyzed data not found'},
                status=status.HTTP_404_NOT_FOUND
            )

        if bill.status != TallyVendorBill.BillStatus.ANALYSED:
            return Response(
                {'error': 'Bill is not in analyzed status'},
                status=status.HTTP_400_BAD_REQUEST
            )

        try:
            verified_bill = self._verify_bill_data(analyzed_bill, serializer.validated_data, organization)

            # Update bill status
            bill.status = TallyVendorBill.BillStatus.VERIFIED
            bill.save(update_fields=['status'])

            response_serializer = TallyVendorAnalyzedBillSerializer(verified_bill)
            return Response(response_serializer.data, status=status.HTTP_200_OK)

        except Exception as e:
            logger.error(f"Bill verification failed: {str(e)}")
            return Response(
                {'error': f'Verification failed: {str(e)}'},
                status=status.HTTP_400_BAD_REQUEST
            )

    def _verify_bill_data(self, analyzed_bill, verification_data, organization):
        """Verify and update bill data"""
        with transaction.atomic():
            # Update bill fields
            if 'vendor_id' in verification_data and verification_data['vendor_id']:
                try:
                    analyzed_bill.vendor = Ledger.objects.get(
                        id=verification_data['vendor_id'],
                        organization=organization
                    )
                except Ledger.DoesNotExist:
                    pass

            # Update basic fields
            for field in ['bill_no', 'bill_date', 'note', 'igst', 'cgst', 'sgst']:
                if field in verification_data:
                    setattr(analyzed_bill, field, verification_data[field])

            # Update tax ledgers
            tax_fields = ['igst_taxes_id', 'cgst_taxes_id', 'sgst_taxes_id']
            for tax_field in tax_fields:
                if tax_field in verification_data and verification_data[tax_field]:
                    ledger_field = tax_field.replace('_id', '')
                    try:
                        tax_ledger = Ledger.objects.get(
                            id=verification_data[tax_field],
                            organization=organization
                        )
                        setattr(analyzed_bill, ledger_field, tax_ledger)
                    except Ledger.DoesNotExist:
                        pass

            analyzed_bill.save()

            # Update products if provided
            if 'products' in verification_data:
                self._update_products(analyzed_bill, verification_data['products'], organization)

            # Validate tax calculations
            self._validate_tax_calculations(analyzed_bill)

            return analyzed_bill

    def _update_products(self, analyzed_bill, products_data, organization):
        """Update analyzed products"""
        for product_data in products_data:
            try:
                product = TallyVendorAnalyzedProduct.objects.get(
                    id=product_data['id'],
                    vendor_bill_analyzed=analyzed_bill
                )

                # Update product fields
                for field in ['item_name', 'item_details', 'price', 'quantity', 'amount', 'product_gst']:
                    if field in product_data:
                        setattr(product, field, product_data[field])

                # Update taxes ledger
                if 'taxes_id' in product_data and product_data['taxes_id']:
                    try:
                        product.taxes = Ledger.objects.get(
                            id=product_data['taxes_id'],
                            organization=organization
                        )
                    except Ledger.DoesNotExist:
                        pass

                # Calculate GST amounts based on product_gst and bill's gst_type
                if 'product_gst' in product_data:
                    self._calculate_product_gst(product, analyzed_bill)

                product.save()

            except TallyVendorAnalyzedProduct.DoesNotExist:
                continue

    def _calculate_product_gst(self, product, analyzed_bill):
        """Calculate GST amounts for product"""
        try:
            if product.product_gst and product.amount:
                gst_percent = float(product.product_gst.strip('%')) if "%" in product.product_gst else 0
                gst_amount = (gst_percent / 100) * float(product.amount or 0)

                # Reset GST amounts
                product.igst = 0
                product.cgst = 0
                product.sgst = 0

                if analyzed_bill.gst_type == TallyVendorAnalyzedBill.GSTType.IGST:
                    product.igst = round(gst_amount, 2)
                elif analyzed_bill.gst_type == TallyVendorAnalyzedBill.GSTType.CGST_SGST:
                    product.cgst = round(gst_amount / 2, 2)
                    product.sgst = round(gst_amount / 2, 2)

        except (ValueError, TypeError) as e:
            logger.warning(f"GST calculation failed for product {product.id}: {e}")

    def _validate_tax_calculations(self, analyzed_bill):
        """Validate that bill taxes match sum of product taxes"""
        products = analyzed_bill.products.all()

        total_product_igst = sum(p.igst or 0 for p in products)
        total_product_cgst = sum(p.cgst or 0 for p in products)
        total_product_sgst = sum(p.sgst or 0 for p in products)

        if analyzed_bill.gst_type == TallyVendorAnalyzedBill.GSTType.IGST:
            if abs(total_product_igst - (analyzed_bill.igst or 0)) > 0.01:
                raise Exception(
                    f"IGST mismatch: Product total={total_product_igst}, Bill total={analyzed_bill.igst}"
                )
        elif analyzed_bill.gst_type == TallyVendorAnalyzedBill.GSTType.CGST_SGST:
            if (abs(total_product_cgst - (analyzed_bill.cgst or 0)) > 0.01 or
                    abs(total_product_sgst - (analyzed_bill.sgst or 0)) > 0.01):
                raise Exception(
                    f"CGST/SGST mismatch: Product CGST/SGST={total_product_cgst}/{total_product_sgst}, "
                    f"Bill CGST/SGST={analyzed_bill.cgst}/{analyzed_bill.sgst}"
                )

    @extend_schema(
        summary="Sync Vendor Bill",
        description="Sync verified vendor bill with Tally system",
        request=BillSyncRequestSerializer,
        responses={200: BillSyncResponseSerializer}
    )
    @action(detail=False, methods=['post'])
    def sync(self, request, *args, **kwargs):
        """Sync verified vendor bill with Tally"""
        serializer = BillSyncRequestSerializer(data=request.data)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

        bill_id = serializer.validated_data['bill_id']
        organization = self.get_organization()

        try:
            bill = TallyVendorBill.objects.get(id=bill_id, organization=organization)
            analyzed_bill = TallyVendorAnalyzedBill.objects.get(selected_bill=bill)
        except (TallyVendorBill.DoesNotExist, TallyVendorAnalyzedBill.DoesNotExist):
            return Response(
                {'error': 'Bill or analyzed data not found'},
                status=status.HTTP_404_NOT_FOUND
            )

        if bill.status != TallyVendorBill.BillStatus.VERIFIED:
            return Response(
                {'error': 'Bill is not verified'},
                status=status.HTTP_400_BAD_REQUEST
            )

        try:
            sync_data = self._prepare_sync_data(analyzed_bill, organization)

            # Update bill status to synced
            bill.status = TallyVendorBill.BillStatus.SYNCED
            bill.save(update_fields=['status'])

            return Response(sync_data, status=status.HTTP_200_OK)

        except Exception as e:
            logger.error(f"Bill sync failed: {str(e)}")
            return Response(
                {'error': f'Sync failed: {str(e)}'},
                status=status.HTTP_400_BAD_REQUEST
            )

    def _prepare_sync_data(self, analyzed_bill, organization):
        """Prepare bill data for Tally sync"""
        vendor_ledger = analyzed_bill.vendor

        # Build sync payload with new format
        sync_data = {
            "id": analyzed_bill.id,
            "bill_no": analyzed_bill.bill_no,
            "bill_date": analyzed_bill.bill_date.strftime('%d-%m-%Y') if analyzed_bill.bill_date else None,
            "total": float(analyzed_bill.total or 0),
            "igst": float(analyzed_bill.igst or 0),
            "cgst": float(analyzed_bill.cgst or 0),
            "sgt
